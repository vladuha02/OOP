package lab2;

import java.io.File;
import java.io.IOException;

public class Main {

    public static File createTempFile(String prefix, String suffix) throws IOException {
       return File.createTempFile("prefix", "");
    }

    public static void main(String[] args) {
        Main main = new Main();
        Student[] st = new Student[5];
        st[0] = new Student("Владислав", "Кириленко", 18, 53, 173, 202, "Комп'ютерні науки");
        st[1] = new Student("Іван", "Іванов", 22, 67, 182, 508, "Інженерія програмного забезпечення");
        st[2] = new Student("Григорій", "Остапенко", 37, 120, 199, 105, "Комп'ютерна інженерія");
        st[3] = new Student("Анастасія", "Гаврилова", 23, 49, 164, 644, "Німецька філологія");
        st[4] = new Student("Андрій", "Кирилов", 19, 75, 178, 371, "Системний аналіз");
        st[0].sortStudents(st);

// 39. Продемонструйте у коді  2 способа  обробки виключних ситуацій у методі (з try-catch и  throws), а також
// особливості використання блока finally. У якості обробляємо виключення оберіть будь яке =checked= виключення.
       /* try {
            File.createTempFile("prefix", "");
        } catch (IOException e) {
            System.out.println("File cannot be created.");
        } finally {
            System.out.println("It will be printed anyway after try-catch block.");
        }*/

       Teacher t = new Teacher();
    }
}
***PERSON.JAVA***
package lab2;

// 48. Створіть просту  ієрархію спадкування, яка відповідає сутностям Людина, Студент, Викладач з відповідними
// властивостями. Продемонструйте перевантаження конструкторів та методів, перевизначення методів, особливості роботи
// конструкторів при спадкуванні.

// 49. Створіть тестовий приклад, який демонструє відмінності при використанні різних модифікаторів доступу.
public class Person {
    protected String surname;
    protected String name;
    protected int age;
    protected int weight;
    protected int height;
    protected Person(String surname, String name, int age, int weight, int height) {
        this.surname = surname;
        this.name = name;
        this.age = age;
        this.weight = weight;
        this.height = height;
    }
   protected Person() {
        this.surname = "no";
        this.name = "no";
        this.age = 0;
        this.weight = 0;
        this.height = 0;
       System.out.println("base class");
    }
    @Override
    public String toString() {
        return "surname: " + surname + "\nname: " + name + "\nage: " + age + "\nweight: " + weight + "\nheight: " + height;
    }
}
***STUDENT.JAVA***
package lab2;

import java.util.Scanner;

public class Student extends Person {
    // 36. Створіть метод, який дозволяє сортувати масив Студентів у відповідності до критерію сортування(за віком, за
// прізвищем та інше). Масив та критерій сортування передаються як критерії методу. Сортування реалізувати методом
// =бульбашки=
    int groupNum;
    String specialty;
    Student(String surname, String name, int age, int weight, int height, int groupNum, String specialty) {
        super(surname, name, age, weight, height);
        this.groupNum = groupNum;
        this.specialty = specialty;
    }
    Student() {
        super();
        this.groupNum = 0;
        this.specialty = "no";
    }
    void sortStudents(Student[] st) {
        Student buf;
        boolean isSorted = false;
        Scanner in = new Scanner(System.in);
        System.out.println("sort by: 1 - age, 2 - number of group, 3 - surname, 4 - specialty.");
        int num = in.nextInt();
        switch (num) {
            case 1: {
                while (!isSorted) {
                    isSorted = true;
                    for (int i = 0; i < st.length - 1; i++) {
                        if (st[i].age > st[i + 1].age) {
                            isSorted = false;

                            buf = st[i];
                            st[i] = st[i + 1];
                            st[i + 1] = buf;
                        }
                    }
                }
                for (Student student : st) {
                    System.out.println(student.toString());
                }
            }
            break;
            case 2: {
                while (!isSorted) {
                    isSorted = true;
                    for (int i = 0; i < st.length - 1; i++) {
                        if (st[i].groupNum > st[i + 1].groupNum) {
                            isSorted = false;

                            buf = st[i];
                            st[i] = st[i + 1];
                            st[i + 1] = buf;
                        }
                    }
                }
                for (Student student : st) {
                    System.out.println(student.toString());
                }
            }
            break;
            case 3: {
                while (!isSorted) {
                    isSorted = true;
                    for (int i = 0; i < st.length - 1; i++) {
                        if (st[i].surname.compareTo(st[i + 1].surname) > 0) {
                            isSorted = false;

                            buf = st[i];
                            st[i] = st[i + 1];
                            st[i + 1] = buf;
                        }
                    }
                }
                for (Student student : st) {
                    System.out.println(student.toString());
                }
            }
            break;
            case 4: {
                while (!isSorted) {
                    isSorted = true;
                    for (int i = 0; i < st.length - 1; i++) {
                        for (int j = 0; j < st[i].specialty.length(); j++) {
                            if (st[i].specialty.compareTo(st[i + 1].specialty) > 0) {
                                isSorted = false;

                                buf = st[i];
                                st[i] = st[i + 1];
                                st[i + 1] = buf;
                            }
                        }
                    }
                }
                for (Student student : st) {
                    System.out.println(student.toString());
                }
            }
            break;
            default: {
                System.out.println("You typed a wrong number, try again.");
                break;
            }
        }
    }
    @Override
    public String toString() {
        return super.toString() + "\nGroup number: " + groupNum + "\nAge: " + age + "\nSpecialty: " + specialty;
    }
}
***TEACHER.JAVA***
package lab2;

public class Teacher extends Person {
    private String department;
    Teacher(String surname, String name, int age, int weight, int height, String department) {
       // super(surname, name, age, weight, height);
        this.department = department;
    }
    Teacher() {
       // super();
        this.department = "no";
        System.out.println("derived class");
    }
    @Override
    public String toString() {
        return super.toString() + "\ndepartment: " + department;
    }
}
***ENUMCLASS.JAVA***
package lab2;

public class enumClass {
    Posada posadaName;

}
***ENUMPOSADA***
package lab2;

// 33. Створіть enum Посади, яке відповідає можливій структурі посад підприємства. Продемонструйте можливість задавати
// властивості, конструктори та методи в enum. Забезпечте при цьому можливості змінювати посадові оклади та кількість
// днів відпустки.

public enum Posada {
    TRAINEE,
    JUNIOR,
    MIDDLE,
    SENIOR,
    LEAD,
    DEPUTY_DIRECTOR,
    DIRECTOR
}

